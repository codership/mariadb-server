#
# This test tests the operation of transaction replay. If a potentially
# conflicting remote transaction arrives at just the right time during
# the commit of a local transaction, the local transaction will be aborted
# and replayed.
#
# Because the write set with higher sequence number cannot BF abort
# the victim with lower sequence number, the conflicting remote transaction
# must be executed first and must be allowed to proceed up to the apply
# monitor before sending the COMMIT for the transaction to be replayed.
#

--source include/galera_cluster.inc
--source include/have_innodb.inc
--source include/have_debug_sync.inc
--source include/galera_have_debug_sync.inc

######################################################################
#
# Scenario #1, the victim will have higher seqno and will be replayed
#
######################################################################

--let $wsrep_local_replays_old = `SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'wsrep_local_replays'`

CREATE TABLE t1 (f1 INTEGER PRIMARY KEY, f2 int, f3 int,  unique key keyj (f2));
INSERT INTO t1 VALUES (1, 1, 0);
INSERT INTO t1 VALUES (3, 3, 0);
INSERT INTO t1 VALUES (10, 10, 0);

SET GLOBAL wsrep_slave_threads = 3;
SET GLOBAL DEBUG_DBUG = "d,sync.wsrep_apply_cb";

--connection node_1
# starting a transaction, which deletes and inserts the middle row in test table
# this will be victim of false positive conflict with appliers
SET SESSION wsrep_sync_wait=0;
START TRANSACTION;

DELETE FROM t1 WHERE f2 = 3;
INSERT INTO t1 VALUES (3, 3, 1);


# Control connection to manage sync points for appliers
--connect node_1a, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1a
SET SESSION wsrep_sync_wait=0;

# send from node 2 first INSERT transaction,  which will conflict on GAP lock in node 1
--connection node_2
INSERT INTO t1 VALUES (5, 5, 2);

--connection node_1a
# wait to see the INSERT in apply_cb sync point
SET SESSION DEBUG_SYNC = "now WAIT_FOR sync.wsrep_apply_cb_reached";

# echo first applier seen in wait point, set sync point for the second INSERT
--let $galera_sync_point = apply_monitor_slave_enter_sync
--source include/galera_set_sync_point.inc

--connection node_2
# send second insert into same GAP in test table
INSERT INTO t1 VALUES (4, 4, 2);

--connection node_1a
# wait for the second insert to arrive in his sync point
--let $galera_sync_point = apply_monitor_slave_enter_sync
--source include/galera_wait_sync_point.inc
--source include/galera_clear_sync_point.inc

# both appliers now waiting in separate sync points

# Block the local commit, send the COMMIT and wait until it gets blocked
--let $galera_sync_point = commit_monitor_master_enter_sync
--source include/galera_set_sync_point.inc

--connection node_1
--send COMMIT

--connection node_1a
# wait for the local commit to enter in commit monitor wait state
--let $galera_sync_point = apply_monitor_slave_enter_sync commit_monitor_master_enter_sync
--source include/galera_wait_sync_point.inc
--source include/galera_clear_sync_point.inc


# Let the first applier to proceed and wait until it BF aborts the local victim
# we set sync point right after the BF abort has happened
--let $galera_sync_point = abort_trx_end
--source include/galera_set_sync_point.inc
--source include/galera_clear_sync_point.inc

# set another sync point just before the applier commit
--let $galera_sync_point = commit_monitor_master_enter_sync
--source include/galera_signal_sync_point.inc
--source include/galera_clear_sync_point.inc

# and now release the first applier, it should force local trx to abort
SET GLOBAL DEBUG_DBUG = "";
SET DEBUG_SYNC = "now SIGNAL signal.wsrep_apply_cb";
SET GLOBAL debug_dbug = NULL;
SET debug_sync='RESET';


--echo wait until first applier has done BF abort
--let $galera_sync_point = abort_trx_end
--source include/galera_wait_sync_point.inc

--echo and we can let the first applier to continue and exit
--source include/galera_signal_sync_point.inc
--source include/galera_clear_sync_point.inc

--echo set another sync point for second applier
SET GLOBAL DEBUG_DBUG = "d,sync.wsrep_apply_cb";

--echo letting the second appier to move forward
--let $galera_sync_point = apply_monitor_slave_enter_sync
--source include/galera_signal_sync_point.inc

--echo waiting until second applier is in wait
SET SESSION DEBUG_SYNC = "now WAIT_FOR sync.wsrep_apply_cb_reached";

--echo local commit should now replay and reach commit monitor wait stage

--echo stopping second applier before commit
--let $galera_sync_point = commit_monitor_slave_enter_sync
--source include/galera_set_sync_point.inc
--source include/galera_clear_sync_point.inc

--sleep 5
--echo replaying is hopefully done by now

--echo releasing the second insert, it should force local trx to abort again
SET GLOBAL DEBUG_DBUG = "";
SET DEBUG_SYNC = "now SIGNAL signal.wsrep_apply_cb";
SET GLOBAL debug_dbug = NULL;
SET debug_sync='RESET';


#--let $galera_sync_point = commit_monitor_slave_enter_sync commit_monitor_master_enter_sync
#SELECT * FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'wsrep_debug_sync_waiters';

SELECT * FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'wsrep_debug_sync_waiters';


--let $galera_sync_point = commit_monitor_slave_enter_sync
--source include/galera_signal_sync_point.inc
--source include/galera_clear_sync_point.inc


# Commit succeeds
--connection node_1
--reap

SELECT * FROM t1;

# wsrep_local_replays has increased by 1
--let $wsrep_local_replays_new = `SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'wsrep_local_replays'`
--disable_query_log
--eval SELECT $wsrep_local_replays_new - $wsrep_local_replays_old = 1 AS wsrep_local_replays;
--enable_query_log

--connection node_2
SELECT * FROM t1;


DROP TABLE t1;

