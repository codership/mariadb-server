#
# Test multirow insert rollback
#

--source include/galera_cluster.inc

#
# Case 1: error on multirow insert results in empty transaction
#
CREATE TABLE t1 (f1 INTEGER PRIMARY KEY DEFAULT 0, f2 char(12));

--connection node_1
START TRANSACTION;
--error ER_DUP_ENTRY
INSERT INTO t1 (f2) VALUES ('a'), ('b');
--error ER_UNKNOWN_ERROR
COMMIT;

SELECT COUNT(*) AS expect_0 FROM t1;

--connection node_2
SELECT COUNT(*) AS expect_0 FROM t1;

DROP TABLE t1;


#
# Case 2: error on multirow insert does not affect previous statements
#
CREATE TABLE t1 (f1 INTEGER PRIMARY KEY DEFAULT 0, f2 char(12));

--connection node_1
START TRANSACTION;
INSERT INTO t1 VALUES (1, 'a');
INSERT INTO t1 VALUES (2, 'b');
--error ER_DUP_ENTRY
INSERT INTO t1 (f2) VALUES ('c'), ('d');
COMMIT;

--echo expect (1,'a'), (2, 'b')
SELECT * FROM t1;

--connection node_2
--echo expect (1,'a'), (2, 'b')
SELECT * FROM t1;

DROP TABLE t1;


#
# Case 3: error on autocommit multirow insert
#
CREATE TABLE t1 (f1 INTEGER PRIMARY KEY DEFAULT 0, f2 char(12));

--connection node_1
--error ER_DUP_ENTRY
INSERT INTO t1 (f2) VALUES ('a'),('b');

SELECT COUNT(*) AS expect_0 FROM t1;

--connection node_2
SELECT COUNT(*) AS expect_0 FROM t1;

DROP TABLE t1;


#
# Case 4: FK constraint violation on multirow insert
#
--connection node_1
CREATE TABLE p(id int primary key, j int) ENGINE=InnoDB;
CREATE TABLE c(id int primary key, fk1 int) ENGINE=InnoDB;
ALTER TABLE c ADD FOREIGN KEY (fk1) references p(id);
INSERT INTO p VALUES(1, 0);

START TRANSACTION;
INSERT INTO c VALUES (3,1);
--error ER_NO_REFERENCED_ROW_2
INSERT INTO c VALUES (1,1), (2,2);
COMMIT;

SELECT * FROM p;
SELECT * FROM c;

--connection node_2
SELECT * FROM p;
SELECT * FROM c;

DROP TABLE c;
DROP TABLE p;


#
# Case 5: testing statement rollback
#
#SET SESSION debug_dbug="+d,wsrep_disable_fix";

--connect node_1a, 127.0.0.1, root, , test, $NODE_MYPORT_1
SET GLOBAL DEBUG_DBUG = "d,sync.wsrep_apply_cb";

--connection node_1
CREATE TABLE t1 (f1 int primary key, f2 int);
INSERT INTO t1 VALUES (1,0);

BEGIN;
--error ER_DUP_ENTRY
INSERT INTO t1 VALUES (2,4),(1,1);

--connection node_2
UPDATE t1 SET f2=8 WHERE f1=1;

--connection node_1a
SET DEBUG_SYNC = "now WAIT_FOR sync.wsrep_apply_cb_reached";

--connection node_1
--error ER_UNKNOWN_ERROR
COMMIT;

--connection node_1a
SET DEBUG_SYNC = "now SIGNAL signal.wsrep_apply_cb";

--connection node_1
SELECT * FROM t1;
DROP TABLE t1;


#
# Case 6: testing statement rollback with BF abort
#
CREATE TABLE t1(f1 int primary key, f2 int);
INSERT INTO t1 VALUES (1,0);

--connection node_1a
SET GLOBAL DEBUG_DBUG = "d,sync.wsrep_apply_cb";

--connection node_1
BEGIN;
--error ER_DUP_ENTRY
INSERT INTO t1 VALUES (3,5),(1,1);

--connection node_2
UPDATE t1 SET f2=9 WHERE f1=1;

--connection node_1a
SET DEBUG_SYNC = "now WAIT_FOR sync.wsrep_apply_cb_reached";
SET DEBUG_SYNC = "now SIGNAL signal.wsrep_apply_cb";
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE STATE = 'wsrep applier committed'
--source include/wait_condition.inc

--connection node_1
--error ER_LOCK_DEADLOCK
COMMIT;

SELECT * FROM t1;

# Cleanup
DROP TABLE t1;
SET DEBUG_SYNC='reset';
SET GLOBAL debug_dbug = DEFAULT;

